structure T = Term
structure TY = Type
(* structure TLC = TopLevelCommands *)
exception Parse of string

fun createLam (var : Var.t) (t : TY.t) (body : T.t) : T.t
  = T.$$(TermOps.Lam t, [(T.\\ (var, body))])

fun createArr (t1 : TY.t) (t2: TY.t) : TY.t =
  Type.$$(TypeOps.ARR, [t1, t2])

val nat = TY.$$(TypeOps.NAT, [])

%%
(* %header (functor LangLrValsFn (structure Token : TOKEN)) *)


%term EOF
    | IDENT of string
    | NATTYPE
    | ARRTYPE
    | ZERO
    | SUCC
    | REC
    | LAMBDA
    | COLON
    | MAPSTO
    | LPAREN
    | RPAREN
    | LCURLY
    | RCURLY
    | BAR
    | WITH
    | END
    | STEP
    | EVAL
    | CHECKED
    | UNCHECKED
    | SEMI

%nonterm ty of TY.t
       | exp of T.t
       | lambda of T.t
       | start of T.t
       | var of T.t

%verbose
%pos int
%start start
%eop EOF SEMI
%noshift EOF SEMI
%name Exp
%left ARRTYPE

%%

start : exp (exp)

exp : ZERO (T.$$(TermOps.Zero, []))
    | SUCC LPAREN exp RPAREN (T.$$(TermOps.Succ, [exp1]))
    | var (var)
    | LAMBDA lambda (lambda)
                (* | REC exp *)
                (* LCURLY *)
                (* ZERO MAPSTO exp *)
                (* BAR SUCC LPAREN exp RPAREN WITH exp MAPSTO exp *)
                (* RCURLY             (T.$$(TermOps.Rec, [exp2, exp3, exp1])) *)
                (* | exp LPAREN exp RPAREN (T.$$(TermOps.App, [exp1, exp2])) *)

ty : NATTYPE                (nat)
   | ty ARRTYPE ty          ( createArr ty1 ty2 )

lambda : LPAREN IDENT COLON ty RPAREN exp (let
                                              val x = ParserState.addvar IDENT
                                          in
                                              createLam x ty exp
                                          end)

var : IDENT     (T.`` (ParserState.getvar IDENT))
