structure T = Term
structure TY = Type
(* structure TLC = TopLevelCommands *)
exception Parse of string

fun createLam (var : Var.t, t : TY.t) (body : T.t) : T.t
  = T.$$(TermOps.Lam t, [(T.\\ (var, body))])

fun createApp (f : T.t) (x : T.t) : T.t =
  T.$$(TermOps.App, [f, x])

fun createArr (t1 : TY.t) (t2: TY.t) : TY.t =
  Type.$$(TypeOps.ARR, [t1, t2])

(* fun createlet (e1,var) e2 =  T.$$(TermOps.Let, [e1, T.\\(var, e2)]) *)

val nat = TY.$$(TypeOps.NAT, [])

%%
%header (functor ExpLrValsFun (structure Token : TOKEN))


%term EOF
    | LET
    | VAL
    | EQUALS
    | IN
    | END
    | IDENT of string
    | NATTYPE
    | ARRTYPE
    | ZERO
    | SUCC
    | REC
    | LAMBDA
    | COLON
    | MAPSTO
    | LPAREN
    | RPAREN
    | LCURLY
    | RCURLY
    | BAR
    | WITH
    | STEP
    | EVAL
    | CHECKED
    | UNCHECKED
    | SEMI

%nonterm ty of TY.t
       | exp of T.t
       | lamexp of T.t
       | lamstart of unit
       | lam1 of T.t
       | lam2 of (Var.t * TY.t)
       | start of T.t
       | var of T.t
       | function of T.t
       | arg of T.t

%verbose
%pos int
%start start
%eop EOF SEMI
%noshift EOF SEMI
%name Exp
%right ARRTYPE
%%

start : exp (exp)

exp : ZERO          %prec ZERO (T.$$(TermOps.Zero, []))
    | SUCC exp      %prec SUCC (T.$$(TermOps.Succ, [exp1]))
    | lamexp       (let
                       val result = lamexp
                       val _ = ParserState.restoretable()
                   in
                       result
                   end)
    | function LPAREN arg RPAREN (createApp function arg)
    | var           (var)
    | LPAREN exp RPAREN  (exp)
    (* | lamexp (createLam lamexp) *)
                (* | REC exp *)
                (* LCURLY *)
                (* ZERO MAPSTO exp *)
                (* BAR SUCC LPAREN exp RPAREN WITH exp MAPSTO exp *)
                (* RCURLY             (T.$$(TermOps.Rec, [exp2, exp3, exp1])) *)
                (* | exp LPAREN exp RPAREN (T.$$(TermOps.App, [exp1, exp2])) *)


function : exp (exp)
arg : exp (exp)

ty : ty ARRTYPE ty          %prec ARRTYPE (createArr ty1 ty2 )
   | NATTYPE                              (nat)

lamexp : lamstart lam1 (lam1)

lamstart : LAMBDA                  (ParserState.savetable())

lam1 : LPAREN lam2 RPAREN exp             ( createLam lam2 exp )

lam2 : IDENT COLON ty (let
                        val var = ParserState.addvar IDENT
                      in
                          (var,ty)
                      end)

var : IDENT     (T.`` (ParserState.getvar IDENT))
